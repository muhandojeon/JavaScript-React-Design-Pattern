# 자바스크립트 디자인 패턴

## 생성자 패턴

- ES2015 이후 생성자를 가진 클래스를 만들 수 있음
  - 클래스는 자바스크립트가 가진 프로토타입의 상속을 이용한 문법적 설탕

- 생성자로 객체를 생성할 떄마다 같은 함수를 새로 정의한다

```js
class User {
  constructor(name) {
    this.name = name;
  }

  sayHi() {
    console.log('hi', this.name);
  }
}

const user1 = new User('John');
user1.sayHi();

const user2 = new User('Jane');
user2.sayHi();

user1.sayHi === user2.sayHi;
// 책의 내용에 따르면 false가 나와야하는데, 왜 true가 나오지?
// 검색해보니 이게 맞다고 함;;

class User {
  constructor(name) {
    this.name = name;
    this.sayHi = () => {
      console.log('hi', this.name);
    }
  }
}

// 이 경우에는 false가 나옴
```

## 모듈 패턴

- 그냥 import, export하는 거라고 이해됨

- 클로저를 이용해 비공개 상태와 구성을 캡슐화

### 믹스인 가져오기 변형

```js
// util.js
export const min = () => {};

// privateUtil.js
import { min } from './util.js';

export const privateMin = () => {
  console.log(min([1,2,3]));
}

// myModule.js
import { privateMin } from './privateUtil.js';

const myModule = () => ({
  publicMethod: () => {
    privateMin();
  }
})
```

- 이 형태의 장점은 모듈 사이의 의존성을 관리하고 전역 요소를 원하는 만큼 넘겨주어 코드의 유지보수를 용이하게 하고 독립적으로 만들어준다는데
  - 솔직히 잘 이해안감
  - export하는 순간 모듈이 되는 거 아닌가?

### WeakMap을 사용하는 최신 모듈 패턴

- ES6에 도입된 WeakMap 객체는 약한 참조를 가진 키-값의 쌍으로 이루어진 집합체
  - 키는 객체여야만 하지만, 값은 다 가능
  - 키가 약하게 유지되는 맵인데, 즉 참조된지 않는 키는 가비지 컬렉션의 대상이 된다는 뜻

```js
let _counter = new WeakMap();

class Module {
  constructor() {
    _counter.set(this, 0);
  }

  increment() {
    const counter = _counter.get(this) + 1;
    _counter.set(this, counter);
    return counter;
  }
}
```

## 싱글톤 패턴

- 클래스의 인스턴스가 오직 하나만 존재하도록 제한하는 패턴

```js
let instance;

class MySingleton {
  constructor() {
    if (instance) {
      return instance;
    }
    instance = this;
  }
}
```

- 이렇게 초기화를 지연할 수 있음

> 개인적으로 초기화 지연없이 아래와 같은 싱글톤 패턴을 사용하곤 했음

```js
class MySingleton {
  constructor() {}
}
export const instance = new MySingleton();
```

- 다만 자바스크립트에서 싱글톤이 필요하다는 것은 설계를 다시 생각해 봐야 한다는 신호일 수 있음
  - 다른 언어와 달리 직접 객체를 생성할 수 있기 때문임
  
- 단점
  - 싱글톤임을 파악하기 힘듬
  - 테스트하기 힘듬
  - 신중한 조정이 필요

- 리액트의 상태 관리
  - 싱글톤과 달리 Context API, Redux 같은 도구는 변경 불가능한 읽기 상태를 제공
  - 의도한 대로 변경될 수 있도록 도와줌

## 프로토타입 패턴

- GoF는 이미 존재하는 객체를 복제해 만든 템플릿을 기반으로 새 객체를 생성하는 패턴이라고 정의

- 프로토타입 패턴의 장점은 다른 언어의 기능을 따라 하지 않고, 자바스크립트만이 가진 고유의 방식으로 작업할 수 있다는 것 (다른 패턴과 구별되는 특징)

```js
const myCar = {
  name: 'Ford',
  drive() {
    console.log('driving...');
  }
}

const yourCar = Object.create(myCar);
```

- `Object.create`는 다른 객체로부터 직접 상속할 수 있게 해주는 차등 상속과 같은 고급 개념을 쉽게 구현할 수 있게 해줌

> 차등 상속?

```js
// 차등 상속(Differential Inheritance)
// 차등 상속은 기존 객체의 속성과 메서드를 그대로 상속받되, 필요한 부분만 수정하거나 추가할 수 있는 상속 방식입니다.

// 기본 자동차 객체
const baseCar = {
  brand: 'Unknown',
  type: 'Car',
  start() {
    console.log('시동을 겁니다');
  },
  stop() {
    console.log('시동을 끕니다');
  }
};

// 차등 상속으로 새로운 자동차 객체 생성
const sportsCar = Object.create(baseCar);

// 필요한 속성만 변경
sportsCar.brand = 'Ferrari';
sportsCar.type = 'Sports Car';
// start()와 stop()은 그대로 상속받아 사용

// Object.create의 두 번째 인자로도 가능
```

## 팩토리 패턴

- 객체를 생성하는 일을 전담하는 객체를 만드는 패턴

```js
class Dog {
  constructor(name) {
    this.name = name;
  }
}

class Cat {
  constructor(name) {
    this.name = name;
  }
}

class AnimalFactory {
  constructor() {
    this.animalClass = Dog;
  }

  createAnimal({type, ...rest}) {
    switch(type) {
      case 'dog':
        this.animalClass = Dog;
        break;
      case 'cat':
        this.animalClass = Cat;
        break;
    }
    return new this.animalClass(rest);
  }
}

const animalFactory = new AnimalFactory();
const dog = animalFactory.createAnimal({type: 'dog', name: 'Rex'});
const cat = animalFactory.createAnimal({type: 'cat', name: 'Whiskers'});
```

- 팩토리 패턴을 사용하면 좋은 상황
  - 객체나 컴포넌트의 생성 과정이 높은 복잡성을 가지고 있을 때
  - 상황에 맞춰 다양한 객체 인스턴스를 편리하게 생성할 수 있는 방법이 필요할 때
  - 같은 속성을 공유하는 여러 개의 작은 객체 또는 컴포넌트를 다뤄야 할 때
  - 덕 타이핑 같은 API 규칙만 충족하면 되는 다른 객체의 인스턴스와 함께 객체를 구성할 때, 또한 디커플링에도 유용

- 사용하면 안 되는 상황
  - 잘못된 상황에서는 애플리케이션의 복잡도가 크게 증가함
  - 객체 생성 인터페이스 제공이 작업 중인 라이브러리나 프레임워크의 설계 목표가 아니라면 위험을 피해 생성자를 사용하는 것이 걍 좋음

### 추상 팩토리 패턴

- 같은 목표를 가진 각각의 팩토리들을 하나의 그룹으로 캡슐화하는 패턴
