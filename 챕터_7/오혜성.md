# 자바스크립트 디자인 패턴

## 생성자 패턴

- ES2015 이후 생성자를 가진 클래스를 만들 수 있음
  - 클래스는 자바스크립트가 가진 프로토타입의 상속을 이용한 문법적 설탕

- 생성자로 객체를 생성할 떄마다 같은 함수를 새로 정의한다

```js
class User {
  constructor(name) {
    this.name = name;
  }

  sayHi() {
    console.log('hi', this.name);
  }
}

const user1 = new User('John');
user1.sayHi();

const user2 = new User('Jane');
user2.sayHi();

user1.sayHi === user2.sayHi;
// 책의 내용에 따르면 false가 나와야하는데, 왜 true가 나오지?
// 검색해보니 이게 맞다고 함;;

class User {
  constructor(name) {
    this.name = name;
    this.sayHi = () => {
      console.log('hi', this.name);
    }
  }
}

// 이 경우에는 false가 나옴
```

## 모듈 패턴

- 그냥 import, export하는 거라고 이해됨

- 클로저를 이용해 비공개 상태와 구성을 캡슐화

### 믹스인 가져오기 변형

```js
// util.js
export const min = () => {};

// privateUtil.js
import { min } from './util.js';

export const privateMin = () => {
  console.log(min([1,2,3]));
}

// myModule.js
import { privateMin } from './privateUtil.js';

const myModule = () => ({
  publicMethod: () => {
    privateMin();
  }
})
```

- 이 형태의 장점은 모듈 사이의 의존성을 관리하고 전역 요소를 원하는 만큼 넘겨주어 코드의 유지보수를 용이하게 하고 독립적으로 만들어준다는데
  - 솔직히 잘 이해안감
  - export하는 순간 모듈이 되는 거 아닌가?

### WeakMap을 사용하는 최신 모듈 패턴

- ES6에 도입된 WeakMap 객체는 약한 참조를 가진 키-값의 쌍으로 이루어진 집합체
  - 키는 객체여야만 하지만, 값은 다 가능
  - 키가 약하게 유지되는 맵인데, 즉 참조된지 않는 키는 가비지 컬렉션의 대상이 된다는 뜻

```js
let _counter = new WeakMap();

class Module {
  constructor() {
    _counter.set(this, 0);
  }

  increment() {
    const counter = _counter.get(this) + 1;
    _counter.set(this, counter);
    return counter;
  }
}
```

## 싱글톤 패턴

- 클래스의 인스턴스가 오직 하나만 존재하도록 제한하는 패턴

```js
let instance;

class MySingleton {
  constructor() {
    if (instance) {
      return instance;
    }
    instance = this;
  }
}
```

- 이렇게 초기화를 지연할 수 있음

> 개인적으로 초기화 지연없이 아래와 같은 싱글톤 패턴을 사용하곤 했음

```js
class MySingleton {
  constructor() {}
}
export const instance = new MySingleton();
```

- 다만 자바스크립트에서 싱글톤이 필요하다는 것은 설계를 다시 생각해 봐야 한다는 신호일 수 있음
  - 다른 언어와 달리 직접 객체를 생성할 수 있기 때문임
  
- 단점
  - 싱글톤임을 파악하기 힘듬
  - 테스트하기 힘듬
  - 신중한 조정이 필요

- 리액트의 상태 관리
  - 싱글톤과 달리 Context API, Redux 같은 도구는 변경 불가능한 읽기 상태를 제공
  - 의도한 대로 변경될 수 있도록 도와줌

## 프로토타입 패턴

- GoF는 이미 존재하는 객체를 복제해 만든 템플릿을 기반으로 새 객체를 생성하는 패턴이라고 정의

- 프로토타입 패턴의 장점은 다른 언어의 기능을 따라 하지 않고, 자바스크립트만이 가진 고유의 방식으로 작업할 수 있다는 것 (다른 패턴과 구별되는 특징)

```js
const myCar = {
  name: 'Ford',
  drive() {
    console.log('driving...');
  }
}

const yourCar = Object.create(myCar);
```

- `Object.create`는 다른 객체로부터 직접 상속할 수 있게 해주는 차등 상속과 같은 고급 개념을 쉽게 구현할 수 있게 해줌

> 차등 상속?

```js
// 차등 상속(Differential Inheritance)
// 차등 상속은 기존 객체의 속성과 메서드를 그대로 상속받되, 필요한 부분만 수정하거나 추가할 수 있는 상속 방식입니다.

// 기본 자동차 객체
const baseCar = {
  brand: 'Unknown',
  type: 'Car',
  start() {
    console.log('시동을 겁니다');
  },
  stop() {
    console.log('시동을 끕니다');
  }
};

// 차등 상속으로 새로운 자동차 객체 생성
const sportsCar = Object.create(baseCar);

// 필요한 속성만 변경
sportsCar.brand = 'Ferrari';
sportsCar.type = 'Sports Car';
// start()와 stop()은 그대로 상속받아 사용

// Object.create의 두 번째 인자로도 가능
```

## 팩토리 패턴

- 객체를 생성하는 일을 전담하는 객체를 만드는 패턴

```js
class Dog {
  constructor(name) {
    this.name = name;
  }
}

class Cat {
  constructor(name) {
    this.name = name;
  }
}

class AnimalFactory {
  constructor() {
    this.animalClass = Dog;
  }

  createAnimal({type, ...rest}) {
    switch(type) {
      case 'dog':
        this.animalClass = Dog;
        break;
      case 'cat':
        this.animalClass = Cat;
        break;
    }
    return new this.animalClass(rest);
  }
}

const animalFactory = new AnimalFactory();
const dog = animalFactory.createAnimal({type: 'dog', name: 'Rex'});
const cat = animalFactory.createAnimal({type: 'cat', name: 'Whiskers'});
```

- 팩토리 패턴을 사용하면 좋은 상황
  - 객체나 컴포넌트의 생성 과정이 높은 복잡성을 가지고 있을 때
  - 상황에 맞춰 다양한 객체 인스턴스를 편리하게 생성할 수 있는 방법이 필요할 때
  - 같은 속성을 공유하는 여러 개의 작은 객체 또는 컴포넌트를 다뤄야 할 때
  - 덕 타이핑 같은 API 규칙만 충족하면 되는 다른 객체의 인스턴스와 함께 객체를 구성할 때, 또한 디커플링에도 유용

- 사용하면 안 되는 상황
  - 잘못된 상황에서는 애플리케이션의 복잡도가 크게 증가함
  - 객체 생성 인터페이스 제공이 작업 중인 라이브러리나 프레임워크의 설계 목표가 아니라면 위험을 피해 생성자를 사용하는 것이 걍 좋음

### 추상 팩토리 패턴

- 같은 목표를 가진 각각의 팩토리들을 하나의 그룹으로 캡슐화하는 패턴

## 구조 패턴

상속의 개념을 통해 인터페이스와 객체를 구성하여 새로운 기능을 추가할 수 있는 것처럼 이것들의 구성을 다룸

- 퍼사드 패턴
- 믹스인 패턴
- 데코레이터 패턴
- 플라이웨이트 패턴

## 퍼사드 패턴

- 실제 모습을 숨기고 꾸며낸 겉모습만을 세상에 드러내는 것
> 건물의 정면에 있는 외벽을 의미한다네요

- 퍼사드는 jQuery같은 라이브러리에서 흔히 볼 수 있는 구조 패턴
  - 밖으로 드러남과 동시에 복잡한 구현은 보이지 않게 숨긴다는 것
  > 이걸 추상화라고 이해하고 있긴 한데, 살짝 다를려나?

```ts
const addMyEvent = (element, event, callback) => {
  if (element.addEventListener) {
    element.addEventListener(event, callback, false);
  } else if (element.attachEvent) {
    element.attachEvent('on' + event, callback);
  } else {
    element['on' + event] = callback;
  }
}
```

## 믹스인 패턴

- 서브클래스가 쉽게 상속받아 기능을 재사용할 수 있도록 하는 클래스랍디다

## 서브클래싱

- 대충 클래스 상속에 대한 설명

## 믹스인

- 자바스크립트의 클래스는 부모 클래스를 하나만 가질 수 있지만 여러 클래스의 기능을 섞는 것으로 확장할 수 있음
  - 표현식이 아니라 문으로 사용할 수도 있음

```js
const MyMixin = (superclass) => class extends superclass {
  sayHi() {
    console.log('hi');
  }
}

class Person {
  sayBye() {
    console.log('bye');
  }
}

const MyPerson = MyMixin(Person);
const person = new MyPerson();
person.sayHi();
person.sayBye();
```

- 함수의 중복을 줄이고 재사용성은 높일 수 있음
- 하지만 클래스나 객체의 프로토타입에 기능을 주입하는 것을 나쁜 방법이라고 여기기도 함
- 출처에 대한 불확실성을 초래하기 때문

- 리액트에서도 ES6 클래스의 도입 이전에는 컴포넌트에 기능을 추가하기 위해 믹스인을 사용하곤 했음
  - 그러나 유지보수와 재사용을 복잡하게 만든다는 이유로 반대

> https://ko.legacy.reactjs.org/docs/react-without-es6.html#mixins
> 근데 문서에서는 그냥 쓰지않는 것을 추천한다고 하네요

## 데코레이터 패턴

- 기존 클래스에 동적으로 기능을 추가하기 위해 사용
  - 서브클래스를 필요에 따라 만든다면 넘모 많이 만들어야해 실용적이지 않음

```js
class MacBook {
  constructor() {
    this.cost = 100;
    this.screenSize = 13;
  }

  getCost() {
    return this.cost;
  }

  getScreenSize() {
    return this.screenSize;
  }
}

class Memory extends MacBook {
  constructor(macbook) {
    super(macbook);
    this.cost = macbook.cost + 1;
  }
}

class Engraving extends MacBook {
  constructor(macbook) {
    super(macbook);
    this.cost = macbook.cost + 2;
  }
}

let myMacBook = new MacBook();
myMacBook = new Memory(myMacBook);
myMacBook = new Engraving(myMacBook);

console.log(myMacBook.getCost());
// 103
console.log(myMacBook.getScreenSize());
// 13
```

### 의사 클래스 데코레이터

- 인터페이스를 이용한 형태로만 이해됨

### 추상 데코레이터

- 이것도 그냥 인터페이스를 이용한 느낌 정도로만 이해됨

> 그래서 준비한 타입스크립트로 작성한 추상 데코레이터 패턴

```tsx
class MacBook {
  // protected ??
  // public = 어디서나 접근 가능
  // private = 이 클래스 내부에서만 접근 가능
  // protected = 이 클래스와 상속받은 클래스에서만 접근 가능
  protected cost: number;
  protected screenSize: number;

  constructor() {
    this.cost = 100;
    this.screenSize = 13;
  }

  getCost(): number {
    return this.cost;
  }

  getScreenSize(): number {
    return this.screenSize;
  }
}

// 데코레이터들이 구현해야 할 인터페이스 (헝가리안 표기법 ㅈㅅ)
interface IMacBook {
  getCost(): number;
  getScreenSize(): number;
}

// 추상 데코레이터 클래스
abstract class MacBookDecorator implements IMacBook {
  protected macbook: IMacBook;

  constructor(macbook: IMacBook) {
    this.macbook = macbook;
  }

  getCost(): number {
    return this.macbook.getCost();
  }

  getScreenSize(): number {
    return this.macbook.getScreenSize();
  }
}

// 구체적인 데코레이터 클래스들
class Memory extends MacBookDecorator {
  getCost(): number {
    return this.macbook.getCost() + 100;  // 메모리 업그레이드 비용 추가
  }
}

// abstract class??
// 추상 클래스라, 직접 인스턴스화 불가능 (new MackBookDecorator)
// 추상 메서드를 포함할 수 있음 (구현부가 없는 메서드)
// 상속받는 클래스에서 추상 메서드를 반드시 구현해야 함
//
// 사용하는 이유
// 1. 공통 기능 구현: 여러 클래스가 공유하는 기본 코드를 구현 (코드 재사용)
// 2. 표준화: 파생되는 클래스들이 반드시 구현하도록 강제
abstract class Shape {
  abstract getArea(): number; // 모든 도형은 면적을 계산해야 함
}

class Circle extends Shape {
  constructor(public radius: number) {
    super();
  }

  getArea(): number {
    return Math.PI * this.radius ** 2;
  }
}
```



